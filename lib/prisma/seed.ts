// ðŸŒ± ì´ íŒŒì¼ì€ ë¬´ì—‡ì¸ê°€ìš”?
// ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë³¸ ë°ì´í„°ë¥¼ ë„£ì–´ì£¼ëŠ” íŒŒì¼ì´ì—ìš”.
// ê²Œìž„ì„ ì‹œìž‘í•  ë•Œ "ê¸°ë³¸ ìºë¦­í„°"ë¥¼ ë§Œë“¤ì–´ì£¼ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•´ìš”!

import 'dotenv/config'; // .env íŒŒì¼ì—ì„œ ë¹„ë°€ë²ˆí˜¸ ê°™ì€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
import { Pool } from 'pg';
import { PrismaPg } from '@prisma/adapter-pg';
import { PrismaClient } from './generated/client';

// ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°í•˜ê¸° (ì§‘ ì£¼ì†Œë¥¼ ì•Œë ¤ì£¼ëŠ” ê²ƒì²˜ëŸ¼)
const pool = new Pool({ connectionString: process.env.DIRECT_URL });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

// ë©”ì¸ í•¨ìˆ˜: ì—¬ê¸°ì„œ ì‹¤ì œë¡œ ë°ì´í„°ë¥¼ ë§Œë“¤ì–´ìš”
async function main() {
  console.log('ðŸŒ± ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë³¸ ë°ì´í„°ë¥¼ ì‹¬ëŠ” ì¤‘...');

  // ============================================================
  // ðŸ“– ì—¬ê¸°ì„œ ë¬´ì—‡ì„ í•˜ëŠ” ê±´ê°€ìš”?
  // ============================================================
  // ìš°ë¦¬ ì„œë¹„ìŠ¤ëŠ” "ìž‘ì—… ì‹œê°„ì„ ì˜ˆì¸¡"í•˜ëŠ” ê±°ì˜ˆìš”.
  // ì˜ˆì¸¡í•˜ëŠ” ë°©ë²•ì´ ì—¬ëŸ¬ ê°€ì§€ ìžˆì„ ìˆ˜ ìžˆì–´ìš”.
  //
  // ì˜ˆë¥¼ ë“¤ì–´:
  // - ê°„ë‹¨í•œ ë°©ë²•: ê³¼ê±° í‰ê·  ì‹œê°„ ì‚¬ìš© (ì´ˆë“±í•™ìƒ ìˆ˜ì¤€)
  // - ë˜‘ë˜‘í•œ ë°©ë²•: AIë¡œ ë¹„ìŠ·í•œ ìž‘ì—… ì°¾ê¸° (ì¤‘í•™ìƒ ìˆ˜ì¤€)
  // - ê°œì¸í™” ë°©ë²•: ê°œì¸ë³„ ì†ë„ ë°˜ì˜ (ê³ ë“±í•™ìƒ ìˆ˜ì¤€)
  //
  // ì´ëŸ° "ì˜ˆì¸¡ ë°©ë²•ë“¤"ì„ ë¯¸ë¦¬ ë§Œë“¤ì–´ë‘ëŠ” ê±°ì˜ˆìš”.

  // ============================================================
  // 1ï¸âƒ£ ì²« ë²ˆì§¸ ì˜ˆì¸¡ ë°©ë²•: ê°„ë‹¨í•œ ê·œì¹™ (ì§€ê¸ˆ ì‚¬ìš© ì¤‘)
  // ============================================================
  // ë§ˆì¹˜ "5êµì‹œê¹Œì§€ ìˆ˜ì—…í•˜ë©´ ë³´í†µ 4ì‹œì— ëë‚˜"ì²˜ëŸ¼
  // ê°„ë‹¨í•œ ê·œì¹™ìœ¼ë¡œ ì˜ˆì¸¡í•˜ëŠ” ë°©ë²•ì´ì—ìš”.
  const ruleBasedModel = await prisma.predictionModel.upsert({
    where: { name: 'rule-based-v1' }, // ì´ë¦„ìœ¼ë¡œ ì°¾ê¸°
    update: {}, // ì´ë¯¸ ìžˆìœ¼ë©´ ìˆ˜ì • ì•ˆ í•¨
    create: {
      // ì—†ìœ¼ë©´ ìƒˆë¡œ ë§Œë“¤ê¸°
      name: 'rule-based-v1', // ì´ë¦„: "ê·œì¹™ê¸°ë°˜-ë²„ì „1"
      version: '1.0.0', // ë²„ì „: 1.0.0
      type: 'rule-based', // íƒ€ìž…: ê·œì¹™ ê¸°ë°˜

      // ì„¤ëª…: ì´ ì˜ˆì¸¡ ë°©ë²•ì´ ì–´ë–»ê²Œ ë™ìž‘í•˜ëŠ”ì§€
      description:
        'ê°„ë‹¨í•œ ê·œì¹™ìœ¼ë¡œ ì‹œê°„ì„ ì˜ˆì¸¡í•´ìš”. 30ë¶„ ì´ìƒ ì‰¬ë©´ ìž‘ì—…ì´ ëë‚œ ê²ƒìœ¼ë¡œ ë³´ê³ , ì¹´í…Œê³ ë¦¬ë³„ í‰ê·  ì‹œê°„ìœ¼ë¡œ ì˜ˆì¸¡í•©ë‹ˆë‹¤.',

      // ì„¤ì •ê°’ë“¤ (ì´ ì˜ˆì¸¡ ë°©ë²•ì˜ "ê²Œìž„ ì„¤ì •"ê°™ì€ ê²ƒ)
      config: {
        idleGapMinutes: 30, // 30ë¶„ ì´ìƒ ì‰¬ë©´ "ìž‘ì—… ë" (ì‰¬ëŠ” ì‹œê°„ì€ ìž‘ì—… ì‹œê°„ì— ì•ˆ ë„£ê¸°)
        minSessionMinutes: 5, // ìµœì†Œ 5ë¶„ ì´ìƒ ìž‘ì—…í•´ì•¼ ì¹´ìš´íŠ¸
        maxSessionHours: 12, // ìµœëŒ€ 12ì‹œê°„ê¹Œì§€ë§Œ ì¸ì • (í•˜ë£¨ ì¢…ì¼ì€ ì•„ë‹ˆë‹ˆê¹Œ)
      },

      isActive: true, // ì§€ê¸ˆ ì‚¬ìš© ì¤‘ âœ…
      isDefault: true, // ê¸°ë³¸ ë°©ë²•ìœ¼ë¡œ ì„¤ì • âœ…
    },
  });

  console.log('âœ… ì²« ë²ˆì§¸ ì˜ˆì¸¡ ë°©ë²• ë§Œë“¤ê¸° ì™„ë£Œ:', ruleBasedModel.name);

  // ============================================================
  // 2ï¸âƒ£ ë‘ ë²ˆì§¸ ì˜ˆì¸¡ ë°©ë²•: AIë¡œ ë¹„ìŠ·í•œ ìž‘ì—… ì°¾ê¸° (ë‚˜ì¤‘ì— ì‚¬ìš©)
  // ============================================================
  // "ì§€ë‚œë²ˆì— ë¹„ìŠ·í•œ ìˆ™ì œ í–ˆì„ ë•Œ 2ì‹œê°„ ê±¸ë ¸ìœ¼ë‹ˆ, ì´ë²ˆì—ë„ 2ì‹œê°„ì¯¤?"
  // ì´ë ‡ê²Œ ê³¼ê±° ë¹„ìŠ·í•œ ìž‘ì—…ì„ ì°¾ì•„ì„œ ì˜ˆì¸¡í•˜ëŠ” ë˜‘ë˜‘í•œ ë°©ë²•ì´ì—ìš”.
  const similarityModel = await prisma.predictionModel.upsert({
    where: { name: 'embedding-similarity-v1' },
    update: {},
    create: {
      name: 'embedding-similarity-v1', // ì´ë¦„: "ìœ ì‚¬ë„ê²€ìƒ‰-ë²„ì „1"
      version: '1.0.0',
      type: 'similarity', // íƒ€ìž…: ìœ ì‚¬ë„ ê¸°ë°˜

      description:
        'AIë¡œ ê³¼ê±° ë¹„ìŠ·í•œ ìž‘ì—…ì„ ì°¾ì•„ì„œ ì˜ˆì¸¡í•´ìš”. ë” ì •í™•í•˜ì§€ë§Œ ê³„ì‚°ì´ ë³µìž¡í•´ìš”.',

      config: {
        embeddingModel: 'text-embedding-3-small', // ì‚¬ìš©í•  AI ëª¨ë¸ ì´ë¦„
        topK: 5, // ê°€ìž¥ ë¹„ìŠ·í•œ ìž‘ì—… 5ê°œë¥¼ ì°¾ê¸°
        similarityThreshold: 0.7, // 70% ì´ìƒ ë¹„ìŠ·í•´ì•¼ ì¸ì •
        idleGapMinutes: 30,
      },

      isActive: false, // ì•„ì§ ì‚¬ìš© ì•ˆ í•¨ âŒ (ë‚˜ì¤‘ì— ì¼¤ ê±°ì˜ˆìš”)
      isDefault: false,
    },
  });

  console.log('âœ… ë‘ ë²ˆì§¸ ì˜ˆì¸¡ ë°©ë²• ë§Œë“¤ê¸° ì™„ë£Œ:', similarityModel.name);

  // ============================================================
  // 3ï¸âƒ£ ì„¸ ë²ˆì§¸ ì˜ˆì¸¡ ë°©ë²•: ê°œì¸ë³„ ë§žì¶¤ (ë” ë‚˜ì¤‘ì— ì‚¬ìš©)
  // ============================================================
  // "ì² ìˆ˜ëŠ” ë¹ ë¥¸ íŽ¸ì´ë‹ˆê¹Œ 1.5ì‹œê°„, ì˜í¬ëŠ” ëŠë¦° íŽ¸ì´ë‹ˆê¹Œ 3ì‹œê°„"
  // ì´ë ‡ê²Œ ì‚¬ëžŒë§ˆë‹¤ ë‹¤ë¥¸ ì†ë„ë¥¼ ë°˜ì˜í•˜ëŠ” ê°€ìž¥ ë˜‘ë˜‘í•œ ë°©ë²•ì´ì—ìš”.
  const personalizedModel = await prisma.predictionModel.upsert({
    where: { name: 'personalized-v1' },
    update: {},
    create: {
      name: 'personalized-v1', // ì´ë¦„: "ê°œì¸í™”-ë²„ì „1"
      version: '1.0.0',
      type: 'personalized', // íƒ€ìž…: ê°œì¸í™”

      description:
        'ì‚¬ìš©ìžë§ˆë‹¤ ìž‘ì—… ì†ë„ê°€ ë‹¤ë¥¸ ê±¸ ê³ ë ¤í•´ì„œ ì˜ˆì¸¡í•´ìš”. ê°€ìž¥ ì •í™•í•˜ì§€ë§Œ ë°ì´í„°ê°€ ë§Žì´ í•„ìš”í•´ìš”.',

      config: {
        useUserProfile: true, // ê°œì¸ ì •ë³´ ì‚¬ìš©í•˜ê¸°
        minFeedbackCount: 10, // ìµœì†Œ 10ê°œ ë°ì´í„°ê°€ ìžˆì–´ì•¼ ì‚¬ìš© ê°€ëŠ¥
        learningRate: 0.1, // ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ì–¼ë§ˆë‚˜ ë¹¨ë¦¬ ë°˜ì˜í• ì§€ (10%)
        categoryWeightDecay: 0.95, // ì˜¤ëž˜ëœ ë°ì´í„°ëŠ” 95%ë§Œ ë°˜ì˜ (ìµœê·¼ ë°ì´í„°ê°€ ë” ì¤‘ìš”)
      },

      isActive: false, // ì•„ì§ ì‚¬ìš© ì•ˆ í•¨ âŒ (ë°ì´í„°ê°€ ìŒ“ì´ë©´ ì¼¤ ê±°ì˜ˆìš”)
      isDefault: false,
    },
  });

  console.log('âœ… ì„¸ ë²ˆì§¸ ì˜ˆì¸¡ ë°©ë²• ë§Œë“¤ê¸° ì™„ë£Œ:', personalizedModel.name);

  // ì™„ë£Œ ë©”ì‹œì§€ ì¶œë ¥
  console.log('');
  console.log('ðŸŽ‰ ëª¨ë“  ì˜ˆì¸¡ ë°©ë²• ë§Œë“¤ê¸° ì™„ë£Œ!');
  console.log('');
  console.log('ðŸ“Š ìš”ì•½:');
  console.log(`  - ${ruleBasedModel.name} (ì‚¬ìš© ì¤‘ âœ…, ê¸°ë³¸ ë°©ë²• âœ…)`);
  console.log(`  - ${similarityModel.name} (ëŒ€ê¸° ì¤‘ â¸ï¸)`);
  console.log(`  - ${personalizedModel.name} (ëŒ€ê¸° ì¤‘ â¸ï¸)`);
  console.log('');
  console.log('ðŸ’¡ ì§€ê¸ˆì€ ê°„ë‹¨í•œ ë°©ë²•ë§Œ ì‚¬ìš©í•˜ê³ ,');
  console.log('   ë‚˜ì¤‘ì— ë˜‘ë˜‘í•œ ë°©ë²•ë“¤ì„ í•˜ë‚˜ì”© ì¼¤ ê±°ì˜ˆìš”!');
}

main()
  .catch((e) => {
    console.error('âŒ Seeding failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    await pool.end();
  });
